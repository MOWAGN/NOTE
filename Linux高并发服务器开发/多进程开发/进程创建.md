# 进程创建
## 子进程创建
- 系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建多个新的子进程，形成一个 **进程树** 结构模型。
- 子进程创建函数原型

    ```
    #include <sys/types.h>
    #include <unistd.h>
    pid_t fork(void);    //Linux系统API
    - 描述
        - 该函数通过复制当前父进程来创建一个新进程。子进程和父进程运行在不同的内存空间，在fork()时，两者的内容是相同的。当内存发生写行为时，文件 mmap 和 unmap 使得另外一个不受影响。
    - 作用：用于创建子进程
    - 返回值
        - fork的返回值会返回两次，分别在父进程和子进程中。
        - 成功：子进程中返回0，父进程中返回子进程ID
        - 失败：父进程中返回-1，表示创建失败
    - 创建失败原因
        1. 当前系统的进程数已经达到系统规定上限，只是errno的值被设置为 `EAGAIN` 
        2. 系统内存不足，此时errno的值被设置为 `ENOMEM` 
    ```
    
## 创建案例

```
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main(){
    // 创建子进程
    pid_t pid = fork();

    // 判断是父进程还是子进程
    // 由于fork()成功后返回值返回2次，分别为子进程pid和0
    if(pid > 0){
        // 如果大于0，返回的时子进程pid，当前是父进程
        printf("I am parent process, pid : %d\n", pid);
        printf("pid:%d, ppid:%d\n", getpid(), getppid());
    }
    else if(pid == 0){
        // 当前是子进程
        printf("I am child proceess\n");
        printf("pid : %d, ppid : %d\n", getpid(), getppid());
    }

    // for循环
    for(int i = 0; i<5; i++)
    {
        printf("i : %d, pid : %d\n", i, getpid());
        sleep(1);
    }

    return 0;
} 
```

- 输出结果
    ![](vx_images/493325223249575.png =350x)
    - 由运行结果可知，时间片的存在，进程之间是交错运行。
    - 🌂 没有添加for循环的时候，子进程getppid()得到的返回值为1。原因是此时父进程被杀死，子进程被init进程领养。
        - 可以在for循环中将子进程的存活时间设置得比父进程长，分别在父进程被杀死前后查看ppid，可以观察到这一变化。
        
